<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Lite Pro - Final Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; }
        .stat { background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 15px; margin-bottom: 5px; border: 1px solid #444; font-size: 18px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreVal">0</span></div>
    <div class="stat">Ø§Ù„ØªØ±ØªÙŠØ¨: #1</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const WORLD_SIZE = 10000; 
let baseZoom = 0.6;
let currentZoom = baseZoom;
let view = { x: 0, y: 0 };
let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, pressed: false };
const treats = ['ğŸ', 'ğŸ¬', 'ğŸ©', 'ğŸ•', 'ğŸ“', 'ğŸ§', 'ğŸ­', 'ğŸ‰', 'ğŸ'];

class Snake {
    constructor(x, y, colorPair, isPlayer, faceType) {
        this.segments = [];
        this.baseLen = 25;
        for(let i=0; i<this.baseLen; i++) this.segments.push({x: x - i*5, y: y});
        this.colors = colorPair; 
        this.radius = 22; 
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 3.6; 
        this.isPlayer = isPlayer;
        this.isDead = false;
        this.score = 0;
        this.faceType = faceType;
        this.eatCount = 0; // Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ÙƒÙ„ Ù„Ù„Ù†Ù…Ùˆ
        this.growCount = 0; // Ø¹Ø¯Ø§Ø¯ ÙƒÙ… Ù…Ø±Ø© Ù†Ù…Øª Ù„Ù„Ø²ÙˆÙ…
    }

    draw() {
        if(this.isDead) return;
        
        for (let i = this.segments.length - 1; i >= 0; i--) {
            ctx.beginPath();
            ctx.fillStyle = (Math.floor(i/3) % 2 === 0) ? this.colors[0] : this.colors[1];
            let size = this.radius * (1 - i / (this.segments.length * 5));
            ctx.arc(this.segments[i].x, this.segments[i].y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        let head = this.segments[0];
        ctx.save();
        ctx.translate(head.x, head.y);
        ctx.rotate(this.angle);
        
        ctx.fillStyle = "white";
        // Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙ‚Ø· ØªØªØºÙŠØ± ÙˆØ¬ÙˆÙ‡Ù‡Ø§ØŒ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØ¬Ù‡Ù‡ Ø«Ø§Ø¨Øª ÙˆØ§Ø­ØªØ±Ø§ÙÙŠ
        let eyeR = (this.isPlayer) ? 11 : (this.faceType === 1 ? 14 : 9);
        ctx.beginPath(); ctx.ellipse(12, -12, eyeR, eyeR-2, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(12, 12, eyeR, eyeR-2, 0, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(15, -12, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(15, 12, 5, 0, Math.PI*2); ctx.fill();

        ctx.strokeStyle = "black"; ctx.lineWidth = 3; ctx.beginPath();
        let smile = (this.isPlayer) ? 0.8 : (this.faceType === 2 ? 0.4 : 0.9);
        ctx.arc(5, 0, 11, Math.PI*(1+smile), Math.PI*(1-smile)); ctx.stroke();
        ctx.restore();
    }

    update() {
        if(this.isDead) return;
        let head = { ...this.segments[0] };
        
        let curSpeed = (this.isPlayer && mouse.pressed && this.segments.length > 20) ? this.speed * 1.4 : this.speed;

        if (this.isPlayer) {
            let targetAngle = Math.atan2(mouse.worldY - head.y, mouse.worldX - head.x);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.12; 
        } else {
            let distToPlayer = Math.hypot(player.segments[0].x - head.x, player.segments[0].y - head.y);
            if(distToPlayer < 400 && !player.isDead) {
                let targetA = Math.atan2(player.segments[0].y - head.y, player.segments[0].x - head.x);
                this.angle += (targetA - this.angle) * 0.08;
            } else {
                if (Math.random() < 0.02) this.angle += (Math.random() - 0.5) * 2;
            }
        }

        head.x += Math.cos(this.angle) * curSpeed;
        head.y += Math.sin(this.angle) * curSpeed;

        if(head.x < 0 || head.x > WORLD_SIZE || head.y < 0 || head.y > WORLD_SIZE) this.die();
        this.segments.unshift(head);
        this.segments.pop();
    }

    die() {
        this.isDead = true;
        this.segments.forEach((s, idx) => {
            if(idx % 4 === 0) {
                foods.push({
                    x: s.x + (Math.random()-0.5)*30, 
                    y: s.y + (Math.random()-0.5)*30, 
                    item: treats[Math.floor(Math.random()*treats.length)], 
                    r: 16
                });
            }
        });
        if(this.isPlayer) setTimeout(() => location.reload(), 2000);
    }
}

let player = new Snake(WORLD_SIZE/2, WORLD_SIZE/2, ["#4CAF50", "#ffffff"], true, 0);
let enemies = [];
function spawnEnemies() {
    const skinPairs = [
        ["#F44336", "#ffffff"], ["#2196F3", "#ffffff"], ["#9C27B0", "#FFEB3B"],
        ["#FF9800", "#ffffff"], ["#E91E63", "#00BCD4"], ["#795548", "#ffffff"]
    ];
    for(let i=0; i<40; i++) { // Ø²Ø¯Øª Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª Ù„Ù„Ø¶Ø¹Ù ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª
        enemies.push(new Snake(
            Math.random()*WORLD_SIZE, 
            Math.random()*WORLD_SIZE, 
            skinPairs[i % skinPairs.length], 
            false, 
            Math.floor(Math.random()*3)
        ));
    }
}

let foods = [];
function spawnFood(count) {
    for(let i=0; i<count; i++) {
        foods.push({
            x: Math.random()*WORLD_SIZE,
            y: Math.random()*WORLD_SIZE,
            item: treats[Math.floor(Math.random()*treats.length)],
            r: 16 
        });
    }
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø²ÙˆÙ… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ù…Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨
    if(player.growCount >= 10) {
        currentZoom = Math.max(0.3, baseZoom - (player.growCount / 80));
    }

    view.x = player.segments[0].x - (canvas.width/2) / currentZoom;
    view.y = player.segments[0].y - (canvas.height/2) / currentZoom;

    ctx.save();
    ctx.scale(currentZoom, currentZoom);
    ctx.translate(-view.x, -view.y);

    ctx.strokeStyle = "red"; ctx.lineWidth = 40;
    ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    foods.forEach((f) => {
        ctx.font = `${f.r * 1.8}px Arial`;
        ctx.fillText(f.item, f.x, f.y);
    });

    let allSnakes = [player, ...enemies];
    allSnakes.forEach(s => {
        if(!s.isDead) {
            s.update();
            s.draw();
            
            foods.forEach((f, i) => {
                if(Math.hypot(s.segments[0].x - f.x, s.segments[0].y - f.y) < s.radius + 18) {
                    foods.splice(i, 1);
                    s.score += 5;
                    s.eatCount++;
                    
                    // ÙŠÙ†Ù…Ùˆ Ø¨Ø¹Ø¯ ÙƒÙ„ 3 ÙÙˆØ§ÙƒÙ‡
                    if(s.eatCount >= 3) {
                        s.segments.push({...s.segments[s.segments.length-1]});
                        s.eatCount = 0;
                        s.growCount++;
                        if(s.isPlayer) s.radius += 0.15; // ÙŠØ³Ù…Ù† Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù…Ùˆ
                    }
                    if(s.isPlayer) document.getElementById('scoreVal').innerText = s.score;
                }
            });

            allSnakes.forEach(other => {
                if(s !== other && !other.isDead) {
                    other.segments.forEach((seg, idx) => {
                        if(idx > 3 && Math.hypot(s.segments[0].x - seg.x, s.segments[0].y - seg.y) < s.radius + 5) s.die();
                    });
                }
            });
        }
    });

    ctx.restore();
    if(foods.length < 800) spawnFood(200);
    requestAnimationFrame(animate);
}

function handleInput(e) {
    let clientX = (e.touches ? e.touches[0].clientX : e.clientX);
    let clientY = (e.touches ? e.touches[0].clientY : e.clientY);
    mouse.worldX = clientX / currentZoom + view.x;
    mouse.worldY = clientY / currentZoom + view.y;
}
window.addEventListener('mousemove', handleInput);
window.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e); }, { passive: false });
window.addEventListener('mousedown', () => mouse.pressed = true);
window.addEventListener('mouseup', () => mouse.pressed = false);
window.addEventListener('touchstart', (e) => { mouse.pressed = true; handleInput(e); }, { passive: false });
window.addEventListener('touchend', () => mouse.pressed = false);

spawnFood(1000);
spawnEnemies();
animate();
</script>
</body>
</html>
