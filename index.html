<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Master Lite - Offline</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #121212; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background-image: radial-gradient(#2a2a2a 1px, transparent 1px); background-size: 40px 40px; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; }
        .stat { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px; margin-bottom: 5px; border: 1px solid #444; }
        #instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #888; font-size: 14px; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat" id="score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
    <div class="stat" id="rank">Ø§Ù„ØªØ±ØªÙŠØ¨: #1</div>
</div>
<div id="instructions">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø§ÙˆØ³ Ø£Ùˆ Ø§Ù„Ù„Ù…Ø³ Ù„Ù„ØªØ­Ø±Ùƒ â€¢ Ø§Ø¶ØºØ· Ù…Ø·ÙˆÙ„Ø§Ù‹ Ù„Ù„ØªØ³Ø±ÙŠØ¹ âš¡</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mouse = { x: canvas.width / 2, y: canvas.height / 2, pressed: false };
let score = 0;
let gameActive = true;

// Ù…ØµÙÙˆÙØ§Øª Ø§Ù„ØµÙˆØ±
const snakeFaces = [
    'https://raw.githubusercontent.com/Hippo-Lab/SnakeLite_Assets/main/face_happy_green.png',
    'https://raw.githubusercontent.com/Hippo-Lab/SnakeLite_Assets/main/face_multi_purple.png',
    'https://raw.githubusercontent.com/Hippo-Lab/SnakeLite_Assets/main/face_smile_blue.png',
    'https://raw.githubusercontent.com/Hippo-Lab/SnakeLite_Assets/main/face_winking_orange.png'
];
const treats = ['ğŸ', 'ğŸ¬', 'ğŸ©', 'ğŸ•', 'ğŸ“'];

// ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±
let loadedFaces = [];
let facesToLoad = snakeFaces.length;
snakeFaces.forEach((src, index) => {
    let img = new Image();
    img.onload = () => {
        loadedFaces[index] = img;
        if(--facesToLoad === 0) startNewGame();
    };
    img.onerror = () => {
        // Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø´ÙƒÙ„Ø§Ù‹ Ù…Ø¨Ø³Ø·Ø§Ù‹
        console.error('Failed to load image:', src);
        if(--facesToLoad === 0) startNewGame();
    };
    img.src = src;
});

class Snake {
    constructor(x, y, color, isPlayer, faceIndex) {
        this.x = x; this.y = y;
        this.segments = [];
        for(let i=0; i<15; i++) this.segments.push({x, y});
        this.color = color;
        this.isPlayer = isPlayer;
        this.face = loadedFaces[faceIndex % loadedFaces.length];
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 3.5;
        this.radius = 18;
        this.maxLength = 15;
        this.isDead = false;
        this.isBoosting = false;
    }

    draw() {
        if(this.isDead) return;

        // Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù…
        for (let i = this.segments.length - 1; i >= 0; i--) {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 1 - (i / this.segments.length * 0.5);
            let size = this.radius * (1 - i / this.segments.length * 0.3);
            ctx.arc(this.segments[i].x, this.segments[i].y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ø±Ø³Ù… Ø§Ù„Ø±Ø£Ø³
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.translate(this.segments[0].x, this.segments[0].y);
        ctx.rotate(this.angle + Math.PI/2);
        
        if (this.face) {
            ctx.drawImage(this.face, -this.radius*1.5, -this.radius*1.5, this.radius*3, this.radius*3);
        } else {
            // Ø´ÙƒÙ„ Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙÙŠ Ø­Ø§Ù„ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("X", 0, 0);
        }
        ctx.restore();
    }

    update() {
        if(this.isDead) return;
        let head = { ...this.segments[0] };
        
        // Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø±ÙŠØ¹
        this.isBoosting = (this.isPlayer && mouse.pressed && this.segments.length > 20);
        let curSpeed = this.isBoosting ? this.speed * 2 : this.speed;
        
        if (this.isBoosting && Math.random() > 0.8) {
             let lastSeg = this.segments.pop();
             food.push({x: lastSeg.x, y: lastSeg.y, item: 'âœ¨', size: 10});
        }

        // Ø§Ù„Ø­Ø±ÙƒØ© ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        if (this.isPlayer) {
            let targetAngle = Math.atan2(mouse.y - head.y, mouse.x - head.x);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.1;
        } else {
            // Ø§Ù„Ø¨ÙˆØª ÙŠÙ„Ø­Ù‚ Ø§Ù„Ø·Ø¹Ø§Ù… Ø§Ù„Ù‚Ø±ÙŠØ¨
            let closestFood = null;
            let minDist = Infinity;
            food.forEach(f => {
                let d = Math.hypot(this.x - f.x, this.y - f.y);
                if (d < minDist) {
                    minDist = d;
                    closestFood = f;
                }
            });
            if (closestFood) {
                this.angle = Math.atan2(closestFood.y - this.y, closestFood.x - this.x);
            } else if (Math.random() < 0.02) {
                this.angle += (Math.random() - 0.5);
            }
        }

        head.x += Math.cos(this.angle) * curSpeed;
        head.y += Math.sin(this.angle) * curSpeed;

        this.segments.unshift(head);
        if (this.segments.length > this.maxLength) this.segments.pop();

        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø©
        if (head.x < -this.radius) head.x = canvas.width + this.radius;
        if (head.x > canvas.width + this.radius) head.x = -this.radius;
        if (head.y < -this.radius) head.y = canvas.height + this.radius;
        if (head.y > canvas.height + this.radius) head.y = -this.radius;
        
        this.x = head.x; this.y = head.y;
    }
}

let player;
let enemies = [];
let food = [];

function startNewGame() {
    score = 0;
    document.getElementById('score').innerText = `Ø§Ù„Ù†Ù‚Ø§Ø·: 0`;
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨
    player = new Snake(canvas.width / 2, canvas.height / 2, '#4CAF50', true, 0);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª
    enemies = [];
    for(let i=0; i<3; i++) {
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        let color = ['#F44336', '#2196F3', '#9C27B0'][i];
        enemies.push(new Snake(x, y, color, false, i + 1));
    }
    
    food = [];
    gameActive = true;
    requestAnimationFrame(animate);
}

function spawnFood() {
    if(food.length < 50) {
        food.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            item: treats[Math.floor(Math.random() * treats.length)],
            size: Math.random() * 10 + 15
        });
    }
}

function checkCollisions() {
    const snakes = [player, ...enemies];
    for (let s of snakes) {
        if (s.isDead) continue;
        
        let head = s.segments[0];
        
        // ØªØµØ§Ø¯Ù… Ø±Ø£Ø³ Ø«Ø¹Ø¨Ø§Ù† Ø¨Ø¬Ø³Ù… Ø«Ø¹Ø¨Ø§Ù† Ø¢Ø®Ø±
        for (let otherS of snakes) {
            if (otherS.isDead) continue;
            
            // ØªØ­Ù‚Ù‚ ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† ØªÙØ­Øµ Ø§Ù„Ø±Ø£Ø³ Ù…Ø¹ Ù†ÙØ³Ù‡
            let startIndex = (s === otherS) ? 2 : 0;
            
            for (let i = startIndex; i < otherS.segments.length; i++) {
                let seg = otherS.segments[i];
                let dist = Math.hypot(head.x - seg.x, head.y - seg.y);
                
                if (dist < s.radius + 5) {
                    s.isDead = true;
                    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† Ø¥Ù„Ù‰ Ø·Ø¹Ø§Ù…
                    s.segments.forEach(seg => {
                        food.push({
                            x: seg.x + (Math.random()-0.5)*10,
                            y: seg.y + (Math.random()-0.5)*10,
                            item: treats[Math.floor(Math.random() * treats.length)],
                            size: Math.random() * 5 + 10
                        });
                    });
                    
                    if (s.isPlayer) {
                        // Ù„Ø¹Ø¨Ø© Ø§Ù„Ø®Ø³Ø±Ø§Ù†
                        ctx.fillStyle = "rgba(0,0,0,0.8)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = "white";
                        ctx.font = "50px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("Ù„Ù‚Ø¯ Ø®Ø³Ø±Øª! Ø§Ù†Ù‚Ø± Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯", canvas.width/2, canvas.height/2);
                        gameActive = false;
                        canvas.addEventListener('mousedown', restartGameOnce);
                        canvas.addEventListener('touchstart', restartGameOnce);
                    } else {
                        // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª
                        setTimeout(() => {
                           if(gameActive) {
                               let x = Math.random() * canvas.width;
                               let y = Math.random() * canvas.height;
                               s.x = x; s.y = y;
                               s.segments = [{x, y}];
                               for(let j=0; j<15; j++) s.segments.push({x, y});
                               s.maxLength = 15;
                               s.isDead = false;
                               s.color = ['#F44336', '#2196F3', '#9C27B0'][Math.floor(Math.random()*3)];
                               s.face = loadedFaces[Math.floor(Math.random()*snakeFaces.length)];
                           }
                        }, 2000);
                    }
                    return; // Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ù…ØµÙÙˆÙØ© ÙØ­Øµ Ø§Ù„Ø±Ø£Ø³
                }
            }
        }
        
        // ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø·Ø¹Ø§Ù…
        food.forEach((f, index) => {
            let dist = Math.hypot(head.x - f.x, head.y - f.y);
            if (dist < s.radius + f.size/2) {
                food.splice(index, 1);
                s.maxLength += 3;
                if (s.isPlayer) {
                    score += 10;
                    document.getElementById('score').innerText = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                }
            }
        });
    }
}

function restartGameOnce() {
    canvas.removeEventListener('mousedown', restartGameOnce);
    canvas.removeEventListener('touchstart', restartGameOnce);
    startNewGame();
}

function animate() {
    if (!gameActive) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    spawnFood();
    checkCollisions();

    // ØªØ­Ø¯ÙŠØ« ÙˆØ±Ø³Ù… Ø§Ù„Ø·Ø¹Ø§Ù…
    food.forEach(f => {
        ctx.font = `${f.size}px Arial`;
        ctx.fillText(f.item, f.x, f.y);
    });

    // ØªØ­Ø¯ÙŠØ« ÙˆØ±Ø³Ù… Ø§Ù„Ø«Ø¹Ø§Ø¨ÙŠÙ†
    const snakes = [player, ...enemies];
    snakes.forEach(s => {
        s.update();
        s.draw();
    });

    requestAnimationFrame(animate);
}

// Ø§Ù„ØªØ­ÙƒÙ…
const updateMouse = (e) => {
    mouse.x = e.clientX || e.touches[0].clientX;
    mouse.y = e.clientY || e.touches[0].clientY;
};
window.addEventListener('mousemove', updateMouse);
window.addEventListener('touchmove', updateMouse);
window.addEventListener('mousedown', () => mouse.pressed = true);
window.addEventListener('mouseup', () => mouse.pressed = false);
window.addEventListener('touchstart', () => mouse.pressed = true);
window.addEventListener('touchend', () => mouse.pressed = false);

// Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯Ù…Ø§ ØªØ­Ù…Ù„ Ø§Ù„ØµÙˆØ±
if(facesToLoad === 0) startNewGame();

</script>
</body>
</html>
