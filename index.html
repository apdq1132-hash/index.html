<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Worm Snake Master - Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; }
        .stat { background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 15px; margin-bottom: 5px; border: 1px solid #444; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreVal">0</span></div>
    <div class="stat">Ø§Ù„ØªØ±ØªÙŠØ¨: #1</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù… ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
const WORLD_SIZE = 5000; 
let view = { x: 0, y: 0 };
let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, pressed: false };

class Snake {
    constructor(x, y, color, isPlayer) {
        this.segments = [];
        for(let i=0; i<25; i++) this.segments.push({x: x - i*5, y: y});
        this.color = color;
        this.radius = 18;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 3.8; // Ø³Ø±Ø¹Ø© Ø³Ù„Ø³Ø© ÙˆÙ…ØªÙˆØ§Ø²Ù†Ø©
        this.isPlayer = isPlayer;
        this.isDead = false;
        this.score = 0;
    }

    draw() {
        if(this.isDead) return;

        // Ø±Ø³Ù… Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ù…Ø®Ø·Ø· Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ
        for (let i = this.segments.length - 1; i >= 0; i--) {
            ctx.beginPath();
            ctx.fillStyle = (Math.floor(i/3) % 2 === 0) ? this.color : "#ffffff";
            ctx.globalAlpha = 1 - (i / this.segments.length * 0.5);
            let size = this.radius * (1 - i / (this.segments.length * 2.5));
            ctx.arc(this.segments[i].x, this.segments[i].y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ø±Ø³Ù… Ø§Ù„ÙˆØ¬Ù‡ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ (Ø¹ÙŠÙˆÙ† ÙˆÙÙ…)
        let head = this.segments[0];
        ctx.save();
        ctx.translate(head.x, head.y);
        ctx.rotate(this.angle);
        ctx.globalAlpha = 1;

        // Ø¨ÙŠØ§Ø¶ Ø§Ù„Ø¹ÙŠÙ†
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.ellipse(12, -12, 11, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(12, 12, 11, 10, 0, 0, Math.PI*2); ctx.fill();
        // Ø¨Ø¤Ø¨Ø¤ Ø§Ù„Ø¹ÙŠÙ†
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(16, -12, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(16, 12, 5, 0, Math.PI*2); ctx.fill();
        // Ø§Ù„ÙÙ…
        ctx.strokeStyle = "black"; ctx.lineWidth = 2.5; ctx.beginPath();
        ctx.arc(5, 0, 10, Math.PI*1.2, Math.PI*0.8); ctx.stroke();
        
        ctx.restore();
    }

    update() {
        if(this.isDead) return;
        let head = { ...this.segments[0] };
        
        // Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø³Ù„Ø³ (Boost)
        let curSpeed = (this.isPlayer && mouse.pressed && this.segments.length > 20) ? this.speed * 1.6 : this.speed;

        if (this.isPlayer) {
            let targetAngle = Math.atan2(mouse.worldY - head.y, mouse.worldX - head.x);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.1; // Ø­Ø±ÙƒØ© Ø¯ÙˆØ±Ø§Ù†ÙŠØ© Ø³Ù„Ø³Ø©
        } else {
            // Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„Ø¨ÙˆØªØ§Øª Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø·Ø¹Ø§Ù…
            let closestFood = null;
            let minDist = 300;
            foods.forEach(f => {
                let d = Math.hypot(this.segments[0].x - f.x, this.segments[0].y - f.y);
                if(d < minDist) { minDist = d; closestFood = f; }
            });
            if(closestFood) {
                this.angle = Math.atan2(closestFood.y - this.segments[0].y, closestFood.x - this.segments[0].x);
            } else if (Math.random() < 0.02) {
                this.angle += (Math.random() - 0.5) * 2;
            }
        }

        head.x += Math.cos(this.angle) * curSpeed;
        head.y += Math.sin(this.angle) * curSpeed;

        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø²ÙˆÙ†
        if(head.x < 0 || head.x > WORLD_SIZE || head.y < 0 || head.y > WORLD_SIZE) this.die();

        this.segments.unshift(head);
        this.segments.pop();
    }

    die() {
        this.isDead = true;
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø³Ù… Ù„Ø·Ø¹Ø§Ù… Ø¹Ù†Ø¯ Ø§Ù„Ù…ÙˆØª
        this.segments.forEach(s => {
            foods.push({x: s.x, y: s.y, color: this.color, r: 10, item: 'âœ¨'});
        });
        if(this.isPlayer) setTimeout(() => location.reload(), 1500);
    }
}

let player = new Snake(WORLD_SIZE/2, WORLD_SIZE/2, "#4CAF50", true);
let enemies = [
    new Snake(800, 800, "#F44336", false),
    new Snake(2000, 1000, "#2196F3", false),
    new Snake(1000, 2500, "#9C27B0", false),
    new Snake(3000, 3000, "#FF9800", false)
];
let foods = [];
const treats = ['ğŸ', 'ğŸ¬', 'ğŸ©', 'ğŸ•', 'ğŸ“'];

function spawnFood() {
    if(foods.length < 250) {
        foods.push({
            x: Math.random()*WORLD_SIZE,
            y: Math.random()*WORLD_SIZE,
            color: `hsl(${Math.random()*360}, 100%, 60%)`,
            item: treats[Math.floor(Math.random()*treats.length)],
            r: 15 // Ø­Ø¬Ù… Ø§Ù„ÙØ§ÙƒÙ‡Ø©
        });
    }
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    spawnFood();
    
    // Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØªØªØ¨Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
    view.x = player.segments[0].x - canvas.width/2;
    view.y = player.segments[0].y - canvas.height/2;

    ctx.save();
    ctx.translate(-view.x, -view.y);

    // Ø±Ø³Ù… Ø§Ù„Ø²ÙˆÙ† (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø­Ù…Ø±)
    ctx.strokeStyle = "red"; ctx.lineWidth = 15;
    ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);

    // Ø±Ø³Ù… Ø§Ù„Ø·Ø¹Ø§Ù… (ÙÙˆØ§ÙƒÙ‡)
    foods.forEach((f, i) => {
        ctx.font = `${f.r * 1.5}px Arial`;
        ctx.fillText(f.item, f.x, f.y);
    });

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙ„ ÙˆÙØ­Øµ Ø§Ù„ØªØµØ§Ø¯Ù…
    let allSnakes = [player, ...enemies];
    allSnakes.forEach(s => {
        if(!s.isDead) {
            s.update();
            s.draw();
            
            // Ø£ÙƒÙ„ Ø§Ù„Ø·Ø¹Ø§Ù… ÙˆØ§Ù„Ù†Ù…Ùˆ
            foods.forEach((f, i) => {
                if(Math.hypot(s.segments[0].x - f.x, s.segments[0].y - f.y) < s.radius + 15) {
                    foods.splice(i, 1);
                    s.score += 10;
                    for(let j=0; j<2; j++) s.segments.push({...s.segments[s.segments.length-1]});
                    if(s.isPlayer) document.getElementById('scoreVal').innerText = s.score;
                }
            });

            // ØªØµØ§Ø¯Ù… Ø§Ù„Ø±Ø£Ø³ Ø¨Ø§Ù„Ø¬Ø³Ù… (Ù„Ù„ÙƒÙ„)
            allSnakes.forEach(other => {
                if(s !== other && !other.isDead) {
                    other.segments.forEach(seg => {
                        if(Math.hypot(s.segments[0].x - seg.x, s.segments[0].y - seg.y) < 20) s.die();
                    });
                }
            });
        }
    });

    ctx.restore();
    requestAnimationFrame(animate);
}

window.onmousemove = (e) => {
    mouse.worldX = e.clientX + view.x;
    mouse.worldY = e.clientY + view.y;
};
window.onmousedown = () => mouse.pressed = true;
window.onmouseup = () => mouse.pressed = false;

animate();
</script>
</body>
</html>
