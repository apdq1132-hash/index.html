<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Master - Boss Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; }
        .stat { background: rgba(0,0,0,0.85); padding: 12px 25px; border-radius: 30px; margin-bottom: 8px; border: 2px solid #444; font-size: 20px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreVal">0</span></div>
    <div class="stat">Ø§Ù„ØªØ±ØªÙŠØ¨: #1</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const WORLD_SIZE = 20000; 
let currentZoom = 0.6;
let view = { x: 0, y: 0 };
let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, pressed: false };
const treats = ['ðŸŽ', 'ðŸ¬', 'ðŸ©', 'ðŸ•', 'ðŸ“', 'ðŸ§', 'ðŸ­', 'ðŸ‰', 'ðŸ'];
const powerUps = ['ðŸ§²', 'âš¡'];

class Snake {
    constructor(x, y, colors, isPlayer, startScore = 0) {
        this.segments = [];
        this.radius = 22; 
        this.maxRadius = 200;
        this.isPlayer = isPlayer;
        this.isDead = false;
        this.score = startScore;
        this.eatCount = 0;
        this.growLevel = 0;
        this.magnetTime = 0; 
        this.speedTime = 0;
        this.isBoss = startScore >= 5000;

        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¨ÙˆØª Ø²Ø¹ÙŠÙ…ØŒ Ù†Ø¨Ø¯Ø£Ù‡ Ø¨Ø·ÙˆÙ„ Ø¶Ø®Ù… ÙˆØ³Ù…Ù†Ø©
        let initialSegments = 35 + (startScore / 20);
        for(let i=0; i<initialSegments; i++) this.segments.push({x: x - i*5, y: y});
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø¬Ù… ÙÙˆØ±Ø§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        if(this.score >= 5000) {
            this.radius = 120; // Ø³Ù…Ù†Ø© Ø§Ù„Ø²Ø¹ÙŠÙ…
            this.growLevel = this.score / 50;
        }

        this.colors = colors;
        this.angle = Math.random() * Math.PI * 2;
        this.baseSpeed = 4.8; 
        this.speed = this.baseSpeed;
        
        if(!this.isPlayer) {
            setInterval(() => { if(!this.isDead) this.magnetTime = 600; }, 120000); 
        }
    }

    draw() {
        if(this.isDead) return;
        const step = this.segments.length > 200 ? 4 : (this.segments.length > 100 ? 3 : 2);
        for (let i = this.segments.length - 1; i >= 0; i--) {
            if (i % step !== 0 && i !== 0) continue; 
            ctx.beginPath();
            ctx.fillStyle = (Math.floor(i/3) % 2 === 0) ? this.colors[0] : this.colors[1];
            let size = this.radius * (1 - i / (this.segments.length * 25));
            ctx.arc(this.segments[i].x, this.segments[i].y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        let head = this.segments[0];
        ctx.save();
        ctx.translate(head.x, head.y);
        ctx.rotate(this.angle);
        let eyeR = this.radius * 0.5; 
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.ellipse(this.radius*0.4, -this.radius*0.4, eyeR, eyeR*0.8, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(this.radius*0.4, this.radius*0.4, eyeR, eyeR*0.8, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(this.radius*0.55, -this.radius*0.4, eyeR*0.4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.radius*0.55, this.radius*0.4, eyeR*0.4, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    update() {
        if(this.isDead) return;
        let head = { ...this.segments[0] };
        this.speed = (this.isPlayer && mouse.pressed) ? this.baseSpeed * 1.5 : this.baseSpeed;

        if (this.isPlayer) {
            if (mouse.active) {
                let dx = mouse.worldX - head.x;
                let dy = mouse.worldY - head.y;
                if (Math.hypot(dx, dy) > this.radius) {
                    let targetAngle = Math.atan2(dy, dx);
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.25;
                }
            }
        } else {
            if (Math.random() < 0.02) this.angle += (Math.random() - 0.5) * 2;
        }

        head.x += Math.cos(this.angle) * this.speed;
        head.y += Math.sin(this.angle) * this.speed;
        this.segments.unshift(head);
        this.segments.pop();
        if(head.x < 0 || head.x > WORLD_SIZE || head.y < 0 || head.y > WORLD_SIZE) this.die();
    }

    grow(type) {
        this.eatCount += (type === 'loot') ? 2 : 1; 
        if(this.eatCount >= 2) { 
            this.segments.push({...this.segments[this.segments.length-1]});
            let growthRate = 0.08;
            if (this.score >= 6000 && this.score < 9000) growthRate = 0.25;
            else if (this.score >= 9000) growthRate = 0.01;
            
            if(this.radius < 200) this.radius += growthRate;
            this.eatCount = 0;
            this.growLevel++;
            if(this.isPlayer) currentZoom = Math.max(0.1, 0.6 - (this.growLevel / 180));
        }
    }

    die() {
        if(this.isDead) return;
        this.isDead = true;
        // Ø§Ù„Ù„ÙˆØª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: ÙŠØ³Ù‚Ø· Ù„ÙˆØª ÙƒØ«ÙŠÙ Ø¬Ø¯Ø§Ù‹ ÙŠÙ…Ø«Ù„ Ø­Ø¬Ù… ÙˆØ³Ù…Ù†Ø© Ø§Ù„Ø£ÙØ¹Ù‰ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
        let lootDensity = this.isBoss ? 0.5 : 1.2; 
        this.segments.forEach((s, idx) => {
            if(idx % lootDensity === 0) {
                for(let j=0; j<(this.radius/20); j++) {
                    foods.push({ 
                        x: s.x + (Math.random()-0.5)*this.radius, 
                        y: s.y + (Math.random()-0.5)*this.radius, 
                        item: treats[Math.floor(Math.random()*treats.length)], 
                        type: 'loot' 
                    });
                }
            }
        });

        if(this.isPlayer) setTimeout(() => location.reload(), 2000);
        else {
            setTimeout(() => {
                let index = enemies.indexOf(this);
                if (index > -1) {
                    // Ø¥Ø°Ø§ Ù…Ø§Øª Ø§Ù„Ø²Ø¹ÙŠÙ…ØŒ ÙŠØ±Ø¬Ø¹ Ø¨ÙˆØª Ø¹Ø§Ø¯ÙŠ ØµØºÙŠØ± Ù…ÙƒØ§Ù†Ù‡
                    const skins = [["#F44336", "#ffffff"], ["#2196F3", "#ffffff"], ["#9C27B0", "#FFEB3B"]];
                    enemies[index] = new Snake(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, skins[Math.floor(Math.random()*skins.length)], false, 0);
                }
            }, 1000);
        }
    }
}

let player = new Snake(WORLD_SIZE/2, WORLD_SIZE/2, ["#4CAF50", "#ffffff"], true);
let enemies = [];
let foods = [];

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    view.x = player.segments[0].x - (canvas.width/2) / currentZoom;
    view.y = player.segments[0].y - (canvas.height/2) / currentZoom;
    ctx.save();
    ctx.scale(currentZoom, currentZoom);
    ctx.translate(-view.x, -view.y);
    ctx.strokeStyle = "#e74c3c"; ctx.lineWidth = 100; ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
    
    let all = [player, ...enemies];
    ctx.font = `44px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
    
    foods.forEach((f) => {
        all.forEach(s => {
            if(!s.isDead && s.magnetTime > 0) {
                let d = Math.hypot(s.segments[0].x - f.x, s.segments[0].y - f.y);
                if(d < 650) { f.x += (s.segments[0].x - f.x) * 0.25; f.y += (s.segments[0].y - f.y) * 0.25; }
            }
        });
        ctx.fillText(f.item, f.x, f.y); 
    });

    all.forEach(s => {
        if(!s.isDead) {
            s.update(); s.draw();
            foods.forEach((f, i) => {
                if(Math.hypot(s.segments[0].x - f.x, s.segments[0].y - f.y) < s.radius + 30) {
                    s.score += 1; s.grow(f.type);
                    if(s.isPlayer) document.getElementById('scoreVal').innerText = Math.floor(s.score);
                    foods.splice(i, 1);
                }
            });
            all.forEach(other => {
                if(s !== other && !other.isDead) {
                    other.segments.forEach((seg, idx) => {
                        if(idx > 2 && Math.hypot(s.segments[0].x - seg.x, s.segments[0].y - seg.y) < s.radius + 10) s.die();
                    });
                }
            });
        }
    });
    ctx.restore();
    if(foods.length < 3500) spawnFood(1000);
    requestAnimationFrame(animate);
}

function spawnFood(count) {
    for(let i=0; i<count; i++) {
        foods.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, item: treats[Math.floor(Math.random()*treats.length)], type: 'food' });
    }
}

mouse.active = false;
window.addEventListener('mousemove', (e) => { mouse.active = true; mouse.worldX = e.clientX / currentZoom + view.x; mouse.worldY = e.clientY / currentZoom + view.y; });
window.addEventListener('touchmove', (e) => { e.preventDefault(); mouse.active = true; mouse.worldX = e.touches[0].clientX / currentZoom + view.x; mouse.worldY = e.touches[0].clientY / currentZoom + view.y; }, { passive: false });
window.addEventListener('mousedown', () => mouse.pressed = true);
window.addEventListener('mouseup', () => { mouse.pressed = false; mouse.active = false; });
window.addEventListener('touchstart', (e) => { mouse.pressed = true; mouse.active = true; }, { passive: false });
window.addEventListener('touchend', () => { mouse.pressed = false; mouse.active = false; });

spawnFood(4000);
// Ø¥Ù†Ø´Ø§Ø¡ 5 Ø¨ÙˆØªØ§Øª Ø²Ø¹Ù…Ø§Ø¡ ÙƒØ¨Ø§Ø± (5,000 Ù†Ù‚Ø·Ø©)
for(let i=0; i<5; i++) enemies.push(new Snake(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, ["#FFD700", "#FF4500"], false, 5000));
// Ø¥Ø¶Ø§ÙØ© 5 Ø¨ÙˆØªØ§Øª Ø¹Ø§Ø¯ÙŠØ© Ù„ØªÙƒÙ…Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø¥Ù„Ù‰ 10
for(let i=0; i<5; i++) enemies.push(new Snake(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, ["#F44336", "#ffffff"], false, 0));

animate();
</script>
</body>
</html>
